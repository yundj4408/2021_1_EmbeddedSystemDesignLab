## ARM ISA

### 1. ARM(Advanced RISC Machine)

- #### Thumb 모드 / ARM 모드

  ARM과 x86의 가장 큰 차이점은 Thumb 모드라는 것이 있다는 것이다. ARM 자체가 모바일/임베디드 등 PC와는 다른 환경에 맞춰서 설계했기 때문에 저전력이 핵심 기술 중 한가지였고, 또 한가지로 처음 설계될 당시 임베디드 계열에서는 32bit가 아닌 16bit가 대세였다고 한다. 이러한 여러가지 상황에 맞추기 위해 2가지 모드를 지원하게 되었고, 리버싱을 할 때에도 이 부분을 고려해야 한다. 쉘 코드를 작성할 때에도 당연히 바이트 수를 줄이기 위해 Thumb모드로 작성하는 것이 좋다.

- #### ARM 모드

  **레지스터 :**  R0 ~ R15 (16개)
  **기계어코드 길이 :** 32bits (4 bytes)

  

- #### Thumb 모드

  **레지스터 :** R0 ~ R7 (8개)
  **기계어코드 길이 :** 16bits (2 bytes)

  

- #### Thumb <--> ARM 모드 전환

  BL**X**/B**X**등 **X**로 끝나는 분기문 명령으로 모드 전환

  

- #### 레지스터

  레지스터는 x86과 상당한 차이점이 있다. 일단 범용 레지스터의 수가 더 많으며, x86에는 존재하지 않는 Link Register가 존재한다.

  - **R0~R12 :** 범용 레지스터, 인자값 및 임시 계산 저장소 등
  - **R13(SP)** : Stack Pointer, x86의 ESP와 비슷한 역할 수행
  - **R14(LR) : **Link Register, 함수 호출 전 LR에 리턴 주소를 저장하고 점프함 (함수 호출 시 리턴주소 스택 활용 X)
  - **PC : ** x86에서의 EIP 레지스터와 동일한 역할 수행. 다음에 실행할 코드의 주소 저장

  

- #### Calling Convention (함수 호출 규약)

  x86에서는 cdecl, fastcall, stdcall 등의 다양한 함수 호출 규약이 존재했으나,

  - **R0~R12 : **범용 레지스터, 인자값 및 임시 계산 저장소 등
  - **R13(SP) : **Stack Pointer, x86의 ESP와 비슷한 역할 수행

  

- #### 연산 순서 (보통 <-)

  ex) **ADD R0, R1, #0x2 :** R1에 0x2를 ADD한 결과값을 R0에 저장
  	  **MOV R0, R1 :** R0 레지스터에 R1 레지스터 값을 대입

  

- #### 메모리 연산 - STR, LDR

  **STR :** 메모리 주소에 레지스터 값을 저장 (연산방향 : ->)

  ex) **MOV R0, #0x100 :** R0 레지스터에 0x100 저장

  ​      **MOV R1, #0xFF  :** R1 레지스터에 0xFF 저장

  ​      **STR R1, [R0]     :** 0x100번지에 0xFF 저장

  - [레지스터] : 해당 레지스터의 값에 있는 메모리 주소 (C언어의 포인터와 유사)  

  

  ex) **STR R1, [R0, #4] :** R0+4번지에 R1 레지스터 값을 저장 

  - []안에서 콤마(,)와 숫자상수 #을 이용해 해당 R0에서 상대적인 offset 위치의 메모리 주소 access 가능

  - offset 범위 -4095~4096

  ex) **STR R1, [R0], #4** : R0번지에 R1 레지스터 값을 저장하고, R0의 주소값을 +4

  - []밖에서 콤마(,)와 숫자상수 #는 Post Index 기능

  - 즉 R1값을 R0에 저장하고 R0 주소값을 상수값으로 변화시키는 것

  

  ex) **STR R1, [R0, #4]! :** R0+4번지에 R1 레지스터 값을 저장하고, **R0의 주소값 +4** 

  - ! 는 auto-update 옵션, offset이 +된 값이 해당 레지스터에 저장됨단순히 [R0,#4]는 R0+4번지만 가르키는 것으로 끝나지만, 

  - [R0,#4]!은 R0+4번지를 가르키고, R0=R0+4까지 실행됨(+와 +=차이)

     

  **LDR :** 해당 메모리 주소의 값을 레지스터에 저장 (연산방향 : <-)

  ex) **LDR R1, [R1, #4] :** R1에 4byte 더한 주소에 저장되어 있는 값을 R1에 저장
  

- #### ARM에선 스택을 위한 명령어가 따로 존재하지 않음 (ex. push, pop X)

  - **장점 :** CALL을 연속적으로 사용하는 경우가 아닌, 한번만 CALL 했을 때, 스택을 사용하지 않고, 레지스터를 사용함으로써 속도면에서 큰 이득.
  - **단점** : CALL이 연속적인 즉, 어떤 서브 루틴에서 또 다른 서브 루틴을 콜 했을 때, lr에 복귀할 주소가 또 들어가게 되면서, lr값을 덮어쓰게 한게 된다. 이럴 땐 수동으로 sp(r13)을 이용해 스택에 r14값들을 넣어줘야 한다. 

- 

### 1. ARM Instruction Set Format